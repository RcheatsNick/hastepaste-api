import * as fetch from "node-fetch";
import * as fs from "fs";
import * as dotenv from "dotenv";
import { Crypto } from "../libs/crypto";
dotenv.config();

const crypto = new Crypto();
const { SECRETS_URI, SECRETS_TOKEN } = process.env;

if (!SECRETS_URI || !SECRETS_TOKEN)
    throw "Missing environment variables: SECRETS_URI, SECRETS_TOKEN";

if (process.argv[2] == "GET") {
    fetch(SECRETS_URI, {
        headers: {
            Authorization: SECRETS_TOKEN,
        },
    })
        .then(res => res.json())
        .then(secrets => {
            secrets = secrets.map(secret => {
                return {
                    name: secret.name,
                    content: crypto.decrypt(SECRETS_TOKEN, secret.content),
                };
            });
            let content = "";
            if (!fs.existsSync(".env")) fs.writeFileSync(".env", content);
            else content = fs.readFileSync(".env", "utf-8");
            const parsed = dotenv.parse(content);
            for (let secret of secrets) parsed[secret.name] = secret.content;
            let newData = "# Auto generated by HastePaste secrets manager\n";
            for (let secret in parsed)
                newData += `${secret}=${parsed[secret]}\n`;
            fs.writeFileSync(".env", newData);
        });
} else if (process.argv[2] == "POST") {
    let content = "";
    if (!fs.existsSync(".env")) fs.writeFileSync(".env", content);
    else content = fs.readFileSync(".env", "utf-8");
    const parsed = dotenv.parse(content);
    for (let secret in parsed) {
        fetch(SECRETS_URI, {
            method: "POST",
            body: JSON.stringify({
                name: secret,
                content: crypto.encrypt(SECRETS_TOKEN, parsed[secret]),
            }),
            headers: {
                "Content-Type": "application/json",
                Authorization: SECRETS_TOKEN,
            },
        });
    }
} else throw "Specify a valid option. Options: GET, POST";
